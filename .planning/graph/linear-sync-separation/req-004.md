---
id: req-004
title: "Wire branch naming and issue linking into runner loop"
dependsOn:
  - req-001
  - req-002
files:
  creates: []
  modifies:
    - src/runner/loop.ts
    - src/linear/sync.ts
    - tests/runner/graph-loop.test.ts
acceptance:
  - "Worktree branch name includes the Linear issue identifier when available: format is baseBranch/TEAM-NNN-reqId (e.g. feat/linear-sync-separation/FRG-42-REQ-001)"
  - "When linearIssueId is missing, logs a warning and falls back to the existing pattern: baseBranch/reqId"
  - "syncRequirementStart accepts an optional branchName parameter and calls client.attachIssueBranch when both linearIssueId and branchName are available"
  - "Tests verify branch naming with and without Linear identifiers, and the attachIssueBranch call in syncRequirementStart"
---

## Context

Linear's GitHub automation matches PRs to issues by finding issue identifiers (like FRG-42) in branch names. Currently Forge creates branches as `baseBranch/reqId` (e.g., `feat/slug/REQ-001`), which Linear can't match.

This requirement wires the new client methods from REQ-002 into the runner loop and sync layer, enabling end-to-end branch-to-issue linking.

## Technical Approach

### loop.ts — branch naming

Before creating the worktree, resolve the Linear issue identifier:

```typescript
// Resolve Linear identifier for branch naming
let issueIdentifier: string | null = null;
const meta = index.requirements[reqId];
if (apiKey && meta?.linearIssueId) {
  try {
    const client = new ForgeLinearClient({ apiKey, teamId: index.linear!.teamId });
    const result = await client.getIssueIdentifier(meta.linearIssueId);
    if (result.success) {
      issueIdentifier = result.data;
    }
  } catch {
    // Best-effort — fall back to reqId-only branch
  }
}

if (!issueIdentifier && meta?.linearIssueId) {
  console.warn(`[forge] Could not resolve Linear identifier for ${reqId} — using reqId-only branch name`);
} else if (!meta?.linearIssueId) {
  console.warn(`[forge] No linearIssueId for ${reqId} — using reqId-only branch name`);
}

const branchSuffix = issueIdentifier ? `${issueIdentifier}-${reqId}` : reqId;
const wtBranch = `${baseBranch}/${branchSuffix}`;
```

Note: The client is instantiated here for the identifier lookup. This is a separate call from the syncRequirementStart call that happens later. Consider extracting client instantiation to avoid creating it twice when LINEAR_API_KEY is set.

### sync.ts — update syncRequirementStart signature

Add an optional `branchName` parameter:

```typescript
export async function syncRequirementStart(
  client: ForgeLinearClient,
  index: GraphIndex,
  requirementId: string,
  branchName?: string,
): Promise<SyncResult> {
  // ... existing issue transition logic ...

  // Attach branch to issue if both are available
  if (meta?.linearIssueId && branchName) {
    try {
      await client.attachIssueBranch(meta.linearIssueId, branchName);
      console.log(`[forge] Attached branch "${branchName}" to issue ${requirementId}`);
    } catch {
      console.warn(`[forge] Failed to attach branch to issue ${requirementId}`);
    }
  }

  // ... existing project transition logic ...
}
```

### loop.ts — pass branch name to syncRequirementStart

Update the sync call to pass the worktree branch name:

```typescript
await syncRequirementStart(client, index, reqId, wtBranch);
```

### Test changes

`tests/runner/graph-loop.test.ts`:
- The existing mock for `syncRequirementStart` accepts any args, so it should still work
- Add a test that verifies the worktree branch includes a Linear identifier when `linearIssueId` is present in the index
- Add a test for the fallback (no linearIssueId) that verifies the old branch pattern

Since the runner tests mock `ForgeLinearClient` and the graph reader, you'll need to set up the mock to return an identifier from `getIssueIdentifier`.

## Interview Notes

- User chose "Warn and fall back" when linearIssueId is missing — log warning, use old branch pattern
- Branch format: `baseBranch/TEAM-NNN-reqId` (e.g., `feat/linear-sync-separation/FRG-42-REQ-001`)
- Client instantiation happens twice in the loop (once for identifier lookup, once for sync) — acceptable for now, can be optimized later
